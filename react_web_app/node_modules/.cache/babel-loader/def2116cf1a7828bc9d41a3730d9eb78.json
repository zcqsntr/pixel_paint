{"ast":null,"code":"const protocol = require('./constants');\n\nconst empty = Buffer.allocUnsafe(0);\nconst zeroBuf = Buffer.from([0]);\n\nconst numbers = require('./numbers');\n\nconst nextTick = require('process-nextick-args').nextTick;\n\nconst debug = require('debug')('mqtt-packet:writeToStream');\n\nconst numCache = numbers.cache;\nconst generateNumber = numbers.generateNumber;\nconst generateCache = numbers.generateCache;\nconst genBufVariableByteInt = numbers.genBufVariableByteInt;\nconst generate4ByteBuffer = numbers.generate4ByteBuffer;\nlet writeNumber = writeNumberCached;\nlet toGenerate = true;\n\nfunction generate(packet, stream, opts) {\n  debug('generate called');\n\n  if (stream.cork) {\n    stream.cork();\n    nextTick(uncork, stream);\n  }\n\n  if (toGenerate) {\n    toGenerate = false;\n    generateCache();\n  }\n\n  debug('generate: packet.cmd: %s', packet.cmd);\n\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts);\n\n    case 'connack':\n      return connack(packet, stream, opts);\n\n    case 'publish':\n      return publish(packet, stream, opts);\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts);\n\n    case 'subscribe':\n      return subscribe(packet, stream, opts);\n\n    case 'suback':\n      return suback(packet, stream, opts);\n\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts);\n\n    case 'unsuback':\n      return unsuback(packet, stream, opts);\n\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts);\n\n    case 'disconnect':\n      return disconnect(packet, stream, opts);\n\n    case 'auth':\n      return auth(packet, stream, opts);\n\n    default:\n      stream.emit('error', new Error('Unknown command'));\n      return false;\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\n\n\nObject.defineProperty(generate, 'cacheNumbers', {\n  get() {\n    return writeNumber === writeNumberCached;\n  },\n\n  set(value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n      writeNumber = writeNumberCached;\n    } else {\n      toGenerate = false;\n      writeNumber = writeNumberGenerated;\n    }\n  }\n\n});\n\nfunction uncork(stream) {\n  stream.uncork();\n}\n\nfunction connect(packet, stream, opts) {\n  const settings = packet || {};\n  const protocolId = settings.protocolId || 'MQTT';\n  const protocolVersion = settings.protocolVersion || 4;\n  const will = settings.will;\n  let clean = settings.clean;\n  const keepalive = settings.keepalive || 0;\n  const clientId = settings.clientId || '';\n  const username = settings.username;\n  const password = settings.password;\n  /* mqtt5 new oprions */\n\n  const properties = settings.properties;\n  if (clean === undefined) clean = true;\n  let length = 0; // Must be a string and non-falsy\n\n  if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n    stream.emit('error', new Error('Invalid protocolId'));\n    return false;\n  } else length += protocolId.length + 2; // Must be 3 or 4 or 5\n\n\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'));\n    return false;\n  } else length += 1; // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n\n\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion === 4) && (clientId || clean)) {\n    length += clientId.length + 2;\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n      return false;\n    }\n\n    if (clean * 1 === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n      return false;\n    }\n  } // Must be a two byte number\n\n\n  if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'));\n    return false;\n  } else length += 2; // Connect flags\n\n\n  length += 1; // Properties\n\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // If will exists...\n\n\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'));\n      return false;\n    } // It must have topic typeof string\n\n\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'));\n      return false;\n    } else {\n      length += Buffer.byteLength(will.topic) + 2;\n    } // Payload\n\n\n    length += 2; // payload length\n\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload);\n        } else {\n          length += will.payload.length;\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'));\n        return false;\n      }\n    } // will properties\n\n\n    var willProperties = {};\n\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties);\n\n      if (!willProperties) {\n        return false;\n      }\n\n      length += willProperties.length;\n    }\n  } // Username\n\n\n  let providedUsername = false;\n\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true;\n      length += Buffer.byteLength(username) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid username'));\n      return false;\n    }\n  } // Password\n\n\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'));\n      return false;\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid password'));\n      return false;\n    }\n  } // Generate header\n\n\n  stream.write(protocol.CONNECT_HEADER); // Generate length\n\n  writeVarByteInt(stream, length); // Generate protocol ID\n\n  writeStringOrBuffer(stream, protocolId);\n  stream.write(protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3); // Connect flags\n\n  let flags = 0;\n  flags |= username != null ? protocol.USERNAME_MASK : 0;\n  flags |= password != null ? protocol.PASSWORD_MASK : 0;\n  flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n  flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n  flags |= will ? protocol.WILL_FLAG_MASK : 0;\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n  stream.write(Buffer.from([flags])); // Keepalive\n\n  writeNumber(stream, keepalive); // Properties\n\n  if (protocolVersion === 5) {\n    propertiesData.write();\n  } // Client ID\n\n\n  writeStringOrBuffer(stream, clientId); // Will\n\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write();\n    }\n\n    writeString(stream, will.topic);\n    writeStringOrBuffer(stream, will.payload);\n  } // Username and password\n\n\n  if (username != null) {\n    writeStringOrBuffer(stream, username);\n  }\n\n  if (password != null) {\n    writeStringOrBuffer(stream, password);\n  } // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n\n\n  return true;\n}\n\nfunction connack(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode;\n  const properties = settings.properties;\n  let length = 2; // length of rc and sessionHeader\n  // Check return code\n\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'));\n    return false;\n  } // mqtt5 properties\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  }\n\n  stream.write(protocol.CONNACK_HEADER); // length\n\n  writeVarByteInt(stream, length);\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n  stream.write(Buffer.from([rc]));\n\n  if (propertiesData != null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction publish(packet, stream, opts) {\n  debug('publish: packet: %o', packet);\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const qos = settings.qos || 0;\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0;\n  const topic = settings.topic;\n  const payload = settings.payload || empty;\n  const id = settings.messageId;\n  const properties = settings.properties;\n  let length = 0; // Topic must be a non-empty string or Buffer\n\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n    stream.emit('error', new Error('Invalid topic'));\n    return false;\n  } // Get the payload length\n\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length; // Message ID must a number if qos > 0\n\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else if (qos) length += 2; // mqtt5 properties\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]); // Remaining length\n\n  writeVarByteInt(stream, length); // Topic\n\n  writeNumber(stream, byteLength(topic));\n  stream.write(topic); // Message ID\n\n  if (qos > 0) writeNumber(stream, id); // Properties\n\n  if (propertiesData != null) {\n    propertiesData.write();\n  } // Payload\n\n\n  debug('publish: payload: %o', payload);\n  return stream.write(payload);\n}\n/* Puback, pubrec, pubrel and pubcomp */\n\n\nfunction confirmation(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const type = settings.cmd || 'puback';\n  const id = settings.messageId;\n  const dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n  let qos = 0;\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 3 : 2;\n  if (type === 'pubrel') qos = 1; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n      if (!propertiesData) {\n        return false;\n      }\n\n      length += propertiesData.length;\n    }\n  } // Header\n\n\n  stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // reason code in header\n\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  } // properies mqtt 5\n\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction subscribe(packet, stream, opts) {\n  debug('subscribe: packet: ');\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const id = settings.messageId;\n  const subs = settings.subscriptions;\n  const properties = settings.properties;\n  let length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2; // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Check subscriptions\n\n\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic;\n      const iqos = subs[i].qos;\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n        return false;\n      }\n\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n        return false;\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false;\n\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n          return false;\n        }\n\n        const rap = subs[i].rap || false;\n\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n          return false;\n        }\n\n        const rh = subs[i].rh || 0;\n\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n          return false;\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'));\n    return false;\n  } // Generate header\n\n\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER);\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Generate length\n\n  writeVarByteInt(stream, length); // Generate message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  let result = true; // Generate subs\n\n  for (const sub of subs) {\n    const jtopic = sub.topic;\n    const jqos = sub.qos;\n    const jnl = +sub.nl;\n    const jrap = +sub.rap;\n    const jrh = sub.rh;\n    let joptions; // Write topic string\n\n    writeString(stream, jtopic); // options process\n\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n    } // Write options\n\n\n    result = stream.write(Buffer.from([joptions]));\n  }\n\n  return result;\n}\n\nfunction suback(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const granted = settings.granted;\n  const properties = settings.properties;\n  let length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2; // Check granted qos vector\n\n\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'));\n        return false;\n      }\n\n      length += 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'));\n    return false;\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // header\n\n\n  stream.write(protocol.SUBACK_HEADER); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return stream.write(Buffer.from(granted));\n}\n\nfunction unsubscribe(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const unsubs = settings.unsubscriptions;\n  const properties = settings.properties;\n  let length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else {\n    length += 2;\n  } // Check unsubs\n\n\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'));\n        return false;\n      }\n\n      length += Buffer.byteLength(unsubs[i]) + 2;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'));\n    return false;\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  } // Unsubs\n\n\n  let result = true;\n\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j]);\n  }\n\n  return result;\n}\n\nfunction unsuback(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const granted = settings.granted;\n  const properties = settings.properties;\n  const type = settings.cmd;\n  const qos = 0;\n  let length = 2; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } // Check granted\n\n\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n\n        length += 1;\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'));\n      return false;\n    }\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  } // payload\n\n\n  if (version === 5) {\n    stream.write(Buffer.from(granted));\n  }\n\n  return true;\n}\n\nfunction emptyPacket(packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd]);\n}\n\nfunction disconnect(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 1 : 0; // properies mqtt 5\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(Buffer.from([protocol.codes.disconnect << 4])); // Length\n\n  writeVarByteInt(stream, length); // reason code in header\n\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  } // properies mqtt 5\n\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction auth(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 1 : 0;\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet')); // properies mqtt 5\n\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n  if (!propertiesData) {\n    return false;\n  }\n\n  length += propertiesData.length; // Header\n\n  stream.write(Buffer.from([protocol.codes.auth << 4])); // Length\n\n  writeVarByteInt(stream, length); // reason code in header\n\n  stream.write(Buffer.from([reasonCode])); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\n\nconst varByteIntCache = {};\n\nfunction writeVarByteInt(stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`));\n    return false;\n  }\n\n  let buffer = varByteIntCache[num];\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num);\n    if (num < 16384) varByteIntCache[num] = buffer;\n  }\n\n  debug('writeVarByteInt: writing to stream: %o', buffer);\n  return stream.write(buffer);\n}\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeString(stream, string) {\n  const strlen = Buffer.byteLength(string);\n  writeNumber(stream, strlen);\n  debug('writeString: %s', string);\n  return stream.write(string, 'utf8');\n}\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeStringPair(stream, name, value) {\n  writeString(stream, name);\n  writeString(stream, value);\n}\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeNumberCached(stream, number) {\n  debug('writeNumberCached: number: %d', number);\n  debug('writeNumberCached: %o', numCache[number]);\n  return stream.write(numCache[number]);\n}\n\nfunction writeNumberGenerated(stream, number) {\n  const generatedNumber = generateNumber(number);\n  debug('writeNumberGenerated: %o', generatedNumber);\n  return stream.write(generatedNumber);\n}\n\nfunction write4ByteNumber(stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number);\n  debug('write4ByteNumber: %o', generated4ByteBuffer);\n  return stream.write(generated4ByteBuffer);\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\n\n\nfunction writeStringOrBuffer(stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite);\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length);\n    stream.write(toWrite);\n  } else writeNumber(stream, 0);\n}\n\nfunction getProperties(stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n\n      write() {\n        writeProperties(stream, {}, 0);\n      }\n\n    };\n  }\n\n  let propertiesLength = 0;\n\n  function getLengthProperty(name, value) {\n    const type = protocol.propertiesTypes[name];\n    let length = 0;\n\n    switch (type) {\n      case 'byte':\n        {\n          if (typeof value !== 'boolean') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 1;\n          break;\n        }\n\n      case 'int8':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 1;\n          break;\n        }\n\n      case 'binary':\n        {\n          if (value && value === null) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + Buffer.byteLength(value) + 2;\n          break;\n        }\n\n      case 'int16':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 2;\n          break;\n        }\n\n      case 'int32':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 4;\n          break;\n        }\n\n      case 'var':\n        {\n          // var byte integer is max 24 bits packed in 32 bits\n          if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + Buffer.byteLength(genBufVariableByteInt(value));\n          break;\n        }\n\n      case 'string':\n        {\n          if (typeof value !== 'string') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 2 + Buffer.byteLength(value.toString());\n          break;\n        }\n\n      case 'pair':\n        {\n          if (typeof value !== 'object') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n            const currentValue = value[name];\n\n            if (Array.isArray(currentValue)) {\n              result += currentValue.reduce((currentLength, value) => {\n                currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString());\n                return currentLength;\n              }, 0);\n            } else {\n              result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n            }\n\n            return result;\n          }, 0);\n          break;\n        }\n\n      default:\n        {\n          stream.emit('error', new Error(`Invalid property ${name}: ${value}`));\n          return false;\n        }\n    }\n\n    return length;\n  }\n\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0;\n      let propValueLength = 0;\n      const propValue = properties[propName];\n\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex]);\n\n          if (!propValueLength) {\n            return false;\n          }\n\n          propLength += propValueLength;\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue);\n\n        if (!propValueLength) {\n          return false;\n        }\n\n        propLength = propValueLength;\n      }\n\n      if (!propLength) return false;\n      propertiesLength += propLength;\n    }\n  }\n\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));\n  return {\n    length: propertiesLengthLength + propertiesLength,\n\n    write() {\n      writeProperties(stream, properties, propertiesLength);\n    }\n\n  };\n}\n\nfunction getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties'];\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n  let propertiesData = getProperties(stream, properties);\n\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift();\n\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp];\n        propertiesData = getProperties(stream, properties);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return propertiesData;\n}\n\nfunction writeProperty(stream, propName, value) {\n  const type = protocol.propertiesTypes[propName];\n\n  switch (type) {\n    case 'byte':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([+value]));\n        break;\n      }\n\n    case 'int8':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([value]));\n        break;\n      }\n\n    case 'binary':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeStringOrBuffer(stream, value);\n        break;\n      }\n\n    case 'int16':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeNumber(stream, value);\n        break;\n      }\n\n    case 'int32':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        write4ByteNumber(stream, value);\n        break;\n      }\n\n    case 'var':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeVarByteInt(stream, value);\n        break;\n      }\n\n    case 'string':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeString(stream, value);\n        break;\n      }\n\n    case 'pair':\n      {\n        Object.getOwnPropertyNames(value).forEach(name => {\n          const currentValue = value[name];\n\n          if (Array.isArray(currentValue)) {\n            currentValue.forEach(value => {\n              stream.write(Buffer.from([protocol.properties[propName]]));\n              writeStringPair(stream, name.toString(), value.toString());\n            });\n          } else {\n            stream.write(Buffer.from([protocol.properties[propName]]));\n            writeStringPair(stream, name.toString(), currentValue.toString());\n          }\n        });\n        break;\n      }\n\n    default:\n      {\n        stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`));\n        return false;\n      }\n  }\n}\n\nfunction writeProperties(stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength);\n\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName];\n\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex]);\n        }\n      } else {\n        writeProperty(stream, propName, value);\n      }\n    }\n  }\n}\n\nfunction byteLength(bufOrString) {\n  if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n}\n\nfunction isStringOrBuffer(field) {\n  return typeof field === 'string' || field instanceof Buffer;\n}\n\nmodule.exports = generate;","map":{"version":3,"sources":["/Users/neythen/Desktop/Projects/LED_paint/web_app/node_modules/mqtt-packet/writeToStream.js"],"names":["protocol","require","empty","Buffer","allocUnsafe","zeroBuf","from","numbers","nextTick","debug","numCache","cache","generateNumber","generateCache","genBufVariableByteInt","generate4ByteBuffer","writeNumber","writeNumberCached","toGenerate","generate","packet","stream","opts","cork","uncork","cmd","connect","connack","publish","confirmation","subscribe","suback","unsubscribe","unsuback","emptyPacket","disconnect","auth","emit","Error","Object","defineProperty","get","set","value","keys","length","writeNumberGenerated","settings","protocolId","protocolVersion","will","clean","keepalive","clientId","username","password","properties","undefined","isBuffer","propertiesData","getProperties","topic","byteLength","payload","willProperties","providedUsername","isStringOrBuffer","write","CONNECT_HEADER","writeVarByteInt","writeStringOrBuffer","VERSION4","VERSION5","VERSION3","flags","USERNAME_MASK","PASSWORD_MASK","retain","WILL_RETAIN_MASK","qos","WILL_QOS_SHIFT","WILL_FLAG_MASK","CLEAN_SESSION_MASK","writeString","version","rc","reasonCode","returnCode","CONNACK_HEADER","sessionPresent","SESSIONPRESENT_HEADER","RETAIN_MASK","id","messageId","PUBLISH_HEADER","dup","type","DUP_MASK","getPropertiesByMaximumPacketSize","ACKS","subs","subscriptions","i","itopic","iqos","nl","rap","rh","SUBSCRIBE_HEADER","result","sub","jtopic","jqos","jnl","jrap","jrh","joptions","SUBSCRIBE_OPTIONS_QOS","SUBSCRIBE_OPTIONS_NL","SUBSCRIBE_OPTIONS_RAP","SUBSCRIBE_OPTIONS_RH","granted","SUBACK_HEADER","unsubs","unsubscriptions","UNSUBSCRIBE_HEADER","j","EMPTY","codes","varByteIntCache","num","VARBYTEINT_MAX","buffer","string","strlen","writeStringPair","name","number","generatedNumber","write4ByteNumber","generated4ByteBuffer","toWrite","writeProperties","propertiesLength","getLengthProperty","propertiesTypes","toString","getOwnPropertyNames","reduce","currentValue","Array","isArray","currentLength","propName","propLength","propValueLength","propValue","valueIndex","propertiesLengthLength","mayEmptyProps","maximumPacketSize","currentMayEmptyProp","shift","writeProperty","forEach","prototype","hasOwnProperty","call","bufOrString","field","module","exports"],"mappings":"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","sourcesContent":["const protocol = require('./constants')\nconst empty = Buffer.allocUnsafe(0)\nconst zeroBuf = Buffer.from([0])\nconst numbers = require('./numbers')\nconst nextTick = require('process-nextick-args').nextTick\nconst debug = require('debug')('mqtt-packet:writeToStream')\n\nconst numCache = numbers.cache\nconst generateNumber = numbers.generateNumber\nconst generateCache = numbers.generateCache\nconst genBufVariableByteInt = numbers.genBufVariableByteInt\nconst generate4ByteBuffer = numbers.generate4ByteBuffer\nlet writeNumber = writeNumberCached\nlet toGenerate = true\n\nfunction generate (packet, stream, opts) {\n  debug('generate called')\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n  debug('generate: packet.cmd: %s', packet.cmd)\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts)\n    case 'connack':\n      return connack(packet, stream, opts)\n    case 'publish':\n      return publish(packet, stream, opts)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts)\n    case 'subscribe':\n      return subscribe(packet, stream, opts)\n    case 'suback':\n      return suback(packet, stream, opts)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts)\n    case 'unsuback':\n      return unsuback(packet, stream, opts)\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts)\n    case 'disconnect':\n      return disconnect(packet, stream, opts)\n    case 'auth':\n      return auth(packet, stream, opts)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get () {\n    return writeNumber === writeNumberCached\n  },\n  set (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (packet, stream, opts) {\n  const settings = packet || {}\n  const protocolId = settings.protocolId || 'MQTT'\n  const protocolVersion = settings.protocolVersion || 4\n  const will = settings.will\n  let clean = settings.clean\n  const keepalive = settings.keepalive || 0\n  const clientId = settings.clientId || ''\n  const username = settings.username\n  const password = settings.password\n  /* mqtt5 new oprions */\n  const properties = settings.properties\n\n  if (clean === undefined) clean = true\n\n  let length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion === 4) && (clientId || clean)) {\n    length += clientId.length + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // Properties\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    length += 2 // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload)\n        } else {\n          length += will.payload.length\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    }\n    // will properties\n    var willProperties = {}\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties)\n      if (!willProperties) { return false }\n      length += willProperties.length\n    }\n  }\n\n  // Username\n  let providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n  stream.write(\n    protocolVersion === 4\n      ? protocol.VERSION4\n      : protocolVersion === 5\n        ? protocol.VERSION5\n        : protocol.VERSION3\n  )\n\n  // Connect flags\n  let flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write()\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write()\n    }\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode\n  const properties = settings.properties\n  let length = 2 // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  // length\n  writeVarByteInt(stream, length)\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  stream.write(Buffer.from([rc]))\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction publish (packet, stream, opts) {\n  debug('publish: packet: %o', packet)\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const qos = settings.qos || 0\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0\n  const topic = settings.topic\n  const payload = settings.payload || empty\n  const id = settings.messageId\n  const properties = settings.properties\n\n  let length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeVarByteInt(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload)\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const type = settings.cmd || 'puback'\n  const id = settings.messageId\n  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  let qos = 0\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 3 : 2\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n      if (!propertiesData) { return false }\n      length += propertiesData.length\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction subscribe (packet, stream, opts) {\n  debug('subscribe: packet: ')\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const id = settings.messageId\n  const subs = settings.subscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic\n      const iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))\n          return false\n        }\n        const rap = subs[i].rap || false\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))\n          return false\n        }\n        const rh = subs[i].rh || 0\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))\n          return false\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  let result = true\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic\n    const jqos = sub.qos\n    const jnl = +sub.nl\n    const jrap = +sub.rap\n    const jrh = sub.rh\n    let joptions\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]))\n  }\n\n  return result\n}\n\nfunction suback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const granted = settings.granted\n  const properties = settings.properties\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const unsubs = settings.unsubscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // Unsubs\n  let result = true\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction unsuback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const granted = settings.granted\n  const properties = settings.properties\n  const type = settings.cmd\n  const qos = 0\n\n  let length = 2\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'))\n          return false\n        }\n        length += 1\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'))\n      return false\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted))\n  }\n  return true\n}\n\nfunction emptyPacket (packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd])\n}\n\nfunction disconnect (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return true\n}\n\nfunction auth (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n  if (!propertiesData) { return false }\n  length += propertiesData.length\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]))\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {}\nfunction writeVarByteInt (stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`))\n    return false\n  }\n\n  let buffer = varByteIntCache[num]\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num)\n    if (num < 16384) varByteIntCache[num] = buffer\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer)\n  return stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  const strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  debug('writeString: %s', string)\n  return stream.write(string, 'utf8')\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair (stream, name, value) {\n  writeString(stream, name)\n  writeString(stream, value)\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  debug('writeNumberCached: number: %d', number)\n  debug('writeNumberCached: %o', numCache[number])\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  const generatedNumber = generateNumber(number)\n  debug('writeNumberGenerated: %o', generatedNumber)\n  return stream.write(generatedNumber)\n}\nfunction write4ByteNumber (stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number)\n  debug('write4ByteNumber: %o', generated4ByteBuffer)\n  return stream.write(generated4ByteBuffer)\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction getProperties (stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write () {\n        writeProperties(stream, {}, 0)\n      }\n    }\n  }\n  let propertiesLength = 0\n  function getLengthProperty (name, value) {\n    const type = protocol.propertiesTypes[name]\n    let length = 0\n    switch (type) {\n      case 'byte': {\n        if (typeof value !== 'boolean') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'int8': {\n        if (typeof value !== 'number' || value < 0 || value > 0xff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'binary': {\n        if (value && value === null) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(value) + 2\n        break\n      }\n      case 'int16': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2\n        break\n      }\n      case 'int32': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 4\n        break\n      }\n      case 'var': {\n        // var byte integer is max 24 bits packed in 32 bits\n        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))\n        break\n      }\n      case 'string': {\n        if (typeof value !== 'string') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2 + Buffer.byteLength(value.toString())\n        break\n      }\n      case 'pair': {\n        if (typeof value !== 'object') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n          const currentValue = value[name]\n          if (Array.isArray(currentValue)) {\n            result += currentValue.reduce((currentLength, value) => {\n              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())\n              return currentLength\n            }, 0)\n          } else {\n            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())\n          }\n          return result\n        }, 0)\n        break\n      }\n      default: {\n        stream.emit('error', new Error(`Invalid property ${name}: ${value}`))\n        return false\n      }\n    }\n    return length\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0\n      let propValueLength = 0\n      const propValue = properties[propName]\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex])\n          if (!propValueLength) { return false }\n          propLength += propValueLength\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue)\n        if (!propValueLength) { return false }\n        propLength = propValueLength\n      }\n      if (!propLength) return false\n      propertiesLength += propLength\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))\n\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write () {\n      writeProperties(stream, properties, propertiesLength)\n    }\n  }\n}\n\nfunction getPropertiesByMaximumPacketSize (stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties']\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0\n\n  let propertiesData = getProperties(stream, properties)\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift()\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp]\n        propertiesData = getProperties(stream, properties)\n      } else {\n        return false\n      }\n    }\n  }\n  return propertiesData\n}\n\nfunction writeProperty (stream, propName, value) {\n  const type = protocol.propertiesTypes[propName]\n  switch (type) {\n    case 'byte': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([+value]))\n      break\n    }\n    case 'int8': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([value]))\n      break\n    }\n    case 'binary': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeStringOrBuffer(stream, value)\n      break\n    }\n    case 'int16': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeNumber(stream, value)\n      break\n    }\n    case 'int32': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      write4ByteNumber(stream, value)\n      break\n    }\n    case 'var': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeVarByteInt(stream, value)\n      break\n    }\n    case 'string': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeString(stream, value)\n      break\n    }\n    case 'pair': {\n      Object.getOwnPropertyNames(value).forEach(name => {\n        const currentValue = value[name]\n        if (Array.isArray(currentValue)) {\n          currentValue.forEach(value => {\n            stream.write(Buffer.from([protocol.properties[propName]]))\n            writeStringPair(stream, name.toString(), value.toString())\n          })\n        } else {\n          stream.write(Buffer.from([protocol.properties[propName]]))\n          writeStringPair(stream, name.toString(), currentValue.toString())\n        }\n      })\n      break\n    }\n    default: {\n      stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`))\n      return false\n    }\n  }\n}\n\nfunction writeProperties (stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength)\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName]\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex])\n        }\n      } else {\n        writeProperty(stream, propName, value)\n      }\n    }\n  }\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n"]},"metadata":{},"sourceType":"script"}